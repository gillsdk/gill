/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type Codec,
  combineCodec,
  type Decoder,
  type Encoder,
  getAddressDecoder,
  getAddressEncoder,
  getBooleanDecoder,
  getBooleanEncoder,
  getOptionDecoder,
  getOptionEncoder,
  getStructDecoder,
  getStructEncoder,
  getU8Decoder,
  getU8Encoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type Option,
  type OptionOrNullable,
  type ReadonlySignerAccount,
  type TransactionSigner,
  transformEncoder,
  type WritableAccount,
} from "@solana/kit";

import { getAccountMetaFactory, ResolvedAccount } from "../../../shared";
import { TOKEN_METADATA_PROGRAM_ADDRESS } from "../programs";
import { type DataV2, type DataV2Args,getDataV2Decoder, getDataV2Encoder } from "../types";

export const UPDATE_METADATA_ACCOUNT_V2_DISCRIMINATOR = 15;

export function getUpdateMetadataAccountV2DiscriminatorBytes() {
  return getU8Encoder().encode(UPDATE_METADATA_ACCOUNT_V2_DISCRIMINATOR);
}

export type UpdateMetadataAccountV2Instruction<
  TProgram extends string = typeof TOKEN_METADATA_PROGRAM_ADDRESS,
  TAccountMetadata extends AccountMeta<string> | string = string,
  TAccountUpdateAuthority extends AccountMeta<string> | string = string,
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> & InstructionWithAccounts<
    [
      TAccountMetadata extends string ? WritableAccount<TAccountMetadata> : TAccountMetadata,
      TAccountUpdateAuthority extends string
        ? AccountSignerMeta<TAccountUpdateAuthority> & ReadonlySignerAccount<TAccountUpdateAuthority>
        : TAccountUpdateAuthority,
      ...TRemainingAccounts,
    ]
  > & InstructionWithData<Uint8Array>;

export type UpdateMetadataAccountV2InstructionData = {
  data: Option<DataV2>;
  discriminator: number;
  isMutable: Option<boolean>;
  primarySaleHappened: Option<boolean>;
  updateAuthority: Option<Address>;
};

export type UpdateMetadataAccountV2InstructionDataArgs = {
  data: OptionOrNullable<DataV2Args>;
  isMutable: OptionOrNullable<boolean>;
  primarySaleHappened: OptionOrNullable<boolean>;
  updateAuthority: OptionOrNullable<Address>;
};

export function getUpdateMetadataAccountV2InstructionDataEncoder(): Encoder<UpdateMetadataAccountV2InstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", getU8Encoder()],
      ["data", getOptionEncoder(getDataV2Encoder())],
      ["updateAuthority", getOptionEncoder(getAddressEncoder())],
      ["primarySaleHappened", getOptionEncoder(getBooleanEncoder())],
      ["isMutable", getOptionEncoder(getBooleanEncoder())],
    ]),
    (value) => ({
      ...value,
      discriminator: UPDATE_METADATA_ACCOUNT_V2_DISCRIMINATOR,
    }),
  );
}

export function getUpdateMetadataAccountV2InstructionDataDecoder(): Decoder<UpdateMetadataAccountV2InstructionData> {
  return getStructDecoder([
    ["discriminator", getU8Decoder()],
    ["data", getOptionDecoder(getDataV2Decoder())],
    ["updateAuthority", getOptionDecoder(getAddressDecoder())],
    ["primarySaleHappened", getOptionDecoder(getBooleanDecoder())],
    ["isMutable", getOptionDecoder(getBooleanDecoder())],
  ]);
}

export function getUpdateMetadataAccountV2InstructionDataCodec(): Codec<
  UpdateMetadataAccountV2InstructionDataArgs,
  UpdateMetadataAccountV2InstructionData
> {
  return combineCodec(
    getUpdateMetadataAccountV2InstructionDataEncoder(),
    getUpdateMetadataAccountV2InstructionDataDecoder(),
  );
}

export type UpdateMetadataAccountV2Input<
  TAccountMetadata extends string = string,
  TAccountUpdateAuthority extends string = string,
> = {
  data: UpdateMetadataAccountV2InstructionDataArgs["data"];
  isMutable: UpdateMetadataAccountV2InstructionDataArgs["isMutable"];
  /** Metadata account */
  metadata: Address<TAccountMetadata>;
  primarySaleHappened: UpdateMetadataAccountV2InstructionDataArgs["primarySaleHappened"];
  /** Update authority key */
  updateAuthority: TransactionSigner<TAccountUpdateAuthority>;
  updateAuthorityArg: UpdateMetadataAccountV2InstructionDataArgs["updateAuthority"];
};

export function getUpdateMetadataAccountV2Instruction<
  TAccountMetadata extends string,
  TAccountUpdateAuthority extends string,
  TProgramAddress extends Address = typeof TOKEN_METADATA_PROGRAM_ADDRESS,
>(
  input: UpdateMetadataAccountV2Input<TAccountMetadata, TAccountUpdateAuthority>,
  config?: { programAddress?: TProgramAddress },
): UpdateMetadataAccountV2Instruction<TProgramAddress, TAccountMetadata, TAccountUpdateAuthority> {
  // Program address.
  const programAddress = config?.programAddress ?? TOKEN_METADATA_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    metadata: { isWritable: true, value: input.metadata ?? null },
    updateAuthority: {
      isWritable: false,
      value: input.updateAuthority ?? null,
    },
  };
  const accounts = originalAccounts as Record<keyof typeof originalAccounts, ResolvedAccount>;

  // Original args.
  const args = { ...input, updateAuthority: input.updateAuthorityArg };

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [getAccountMeta(accounts.metadata), getAccountMeta(accounts.updateAuthority)],
    data: getUpdateMetadataAccountV2InstructionDataEncoder().encode(args as UpdateMetadataAccountV2InstructionDataArgs),
    programAddress,
  } as UpdateMetadataAccountV2Instruction<TProgramAddress, TAccountMetadata, TAccountUpdateAuthority>;

  return instruction;
}

export type ParsedUpdateMetadataAccountV2Instruction<
  TProgram extends string = typeof TOKEN_METADATA_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  accounts: {
    /** Metadata account */
    metadata: TAccountMetas[0];
    /** Update authority key */
    updateAuthority: TAccountMetas[1];
  };
  data: UpdateMetadataAccountV2InstructionData;
  programAddress: Address<TProgram>;
};

export function parseUpdateMetadataAccountV2Instruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> & InstructionWithAccounts<TAccountMetas> & InstructionWithData<Uint8Array>,
): ParsedUpdateMetadataAccountV2Instruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 2) {
    // TODO: Coded error.
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
    const accountMeta = instruction.accounts![accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    accounts: {
      metadata: getNextAccount(),
      updateAuthority: getNextAccount(),
    },
    data: getUpdateMetadataAccountV2InstructionDataDecoder().decode(instruction.data),
    programAddress: instruction.programAddress,
  };
}
