/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  type Account,
  type Address,
  assertAccountExists,
  assertAccountsExist,
  type Codec,
  combineCodec,
  decodeAccount,
  type Decoder,
  type EncodedAccount,
  type Encoder,
  type FetchAccountConfig,
  type FetchAccountsConfig,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  getAddressDecoder,
  getAddressEncoder,
  getBooleanDecoder,
  getBooleanEncoder,
  getOptionDecoder,
  getOptionEncoder,
  getStructDecoder,
  getStructEncoder,
  getU8Decoder,
  getU8Encoder,
  type MaybeAccount,
  type MaybeEncodedAccount,
  type Option,
  type OptionOrNullable,
} from "@solana/kit";

import {
  type Collection,
  type CollectionArgs,
  type CollectionDetails,
  type CollectionDetailsArgs,
  type Data,
  type DataArgs,
  getCollectionDecoder,
  getCollectionDetailsDecoder,
  getCollectionDetailsEncoder,
  getCollectionEncoder,
  getDataDecoder,
  getDataEncoder,
  getKeyDecoder,
  getKeyEncoder,
  getProgrammableConfigDecoder,
  getProgrammableConfigEncoder,
  getTokenStandardDecoder,
  getTokenStandardEncoder,
  getUsesDecoder,
  getUsesEncoder,
  type Key,
  type KeyArgs,
  type ProgrammableConfig,
  type ProgrammableConfigArgs,
  type TokenStandard,
  type TokenStandardArgs,
  type Uses,
  type UsesArgs,
} from "../types";

export type Metadata = {
  collection: Option<Collection>;
  collectionDetails: Option<CollectionDetails>;
  data: Data;
  editionNonce: Option<number>;
  isMutable: boolean;
  key: Key;
  mint: Address;
  primarySaleHappened: boolean;
  programmableConfig: Option<ProgrammableConfig>;
  tokenStandard: Option<TokenStandard>;
  updateAuthority: Address;
  uses: Option<Uses>;
};

export type MetadataArgs = {
  collection: OptionOrNullable<CollectionArgs>;
  collectionDetails: OptionOrNullable<CollectionDetailsArgs>;
  data: DataArgs;
  editionNonce: OptionOrNullable<number>;
  isMutable: boolean;
  key: KeyArgs;
  mint: Address;
  primarySaleHappened: boolean;
  programmableConfig: OptionOrNullable<ProgrammableConfigArgs>;
  tokenStandard: OptionOrNullable<TokenStandardArgs>;
  updateAuthority: Address;
  uses: OptionOrNullable<UsesArgs>;
};

export function getMetadataEncoder(): Encoder<MetadataArgs> {
  return getStructEncoder([
    ["key", getKeyEncoder()],
    ["updateAuthority", getAddressEncoder()],
    ["mint", getAddressEncoder()],
    ["data", getDataEncoder()],
    ["primarySaleHappened", getBooleanEncoder()],
    ["isMutable", getBooleanEncoder()],
    ["editionNonce", getOptionEncoder(getU8Encoder())],
    ["tokenStandard", getOptionEncoder(getTokenStandardEncoder())],
    ["collection", getOptionEncoder(getCollectionEncoder())],
    ["uses", getOptionEncoder(getUsesEncoder())],
    ["collectionDetails", getOptionEncoder(getCollectionDetailsEncoder())],
    ["programmableConfig", getOptionEncoder(getProgrammableConfigEncoder())],
  ]);
}

export function getMetadataDecoder(): Decoder<Metadata> {
  return getStructDecoder([
    ["key", getKeyDecoder()],
    ["updateAuthority", getAddressDecoder()],
    ["mint", getAddressDecoder()],
    ["data", getDataDecoder()],
    ["primarySaleHappened", getBooleanDecoder()],
    ["isMutable", getBooleanDecoder()],
    ["editionNonce", getOptionDecoder(getU8Decoder())],
    ["tokenStandard", getOptionDecoder(getTokenStandardDecoder())],
    ["collection", getOptionDecoder(getCollectionDecoder())],
    ["uses", getOptionDecoder(getUsesDecoder())],
    ["collectionDetails", getOptionDecoder(getCollectionDetailsDecoder())],
    ["programmableConfig", getOptionDecoder(getProgrammableConfigDecoder())],
  ]);
}

export function getMetadataCodec(): Codec<MetadataArgs, Metadata> {
  return combineCodec(getMetadataEncoder(), getMetadataDecoder());
}

export function decodeMetadata<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>,
): Account<Metadata, TAddress>;
export function decodeMetadata<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>,
): MaybeAccount<Metadata, TAddress>;
export function decodeMetadata<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,
): Account<Metadata, TAddress> | MaybeAccount<Metadata, TAddress> {
  return decodeAccount(encodedAccount as MaybeEncodedAccount<TAddress>, getMetadataDecoder());
}

export async function fetchMetadata<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<Account<Metadata, TAddress>> {
  const maybeAccount = await fetchMaybeMetadata(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeMetadata<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<MaybeAccount<Metadata, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeMetadata(maybeAccount);
}

export async function fetchAllMetadata(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<Account<Metadata>[]> {
  const maybeAccounts = await fetchAllMaybeMetadata(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeMetadata(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<MaybeAccount<Metadata>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeMetadata(maybeAccount));
}
